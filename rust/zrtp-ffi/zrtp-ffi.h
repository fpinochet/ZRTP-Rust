/* Generated by cbindgen - DO NOT EDIT */

#ifndef ZRTP_FFI_H
#define ZRTP_FFI_H

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

namespace zrtp {

/// The main ZRTP protocol engine context.
///
/// This struct manages the state machine, cryptographic providers,
/// retransmission logic, and message queuing.
struct ZrtpContext;

/// Callback for state changes.
using ZrtpStatusCallback = void(*)(ZrtpContext *ctx, int32_t state, void *user_data);

extern "C" {

/// Creates a new ZRTP context for a given ZID.
///
/// # Safety
/// The `zid` pointer must point to at least 12 bytes of valid memory.
ZrtpContext *zrtp_context_new(const uint8_t *zid);

/// Creates a new ZRTP context with a persistent SQLite cache.
///
/// # Safety
/// The `zid` pointer must point to at least 12 bytes. `db_path` must be a null-terminated string.
ZrtpContext *zrtp_context_new_with_db(const uint8_t *zid, const char *db_path);

/// Creates a new ZRTP context with a legacy binary file cache.
///
/// # Safety
/// The `zid` pointer must point to at least 12 bytes. `file_path` must be a null-terminated string.
ZrtpContext *zrtp_context_new_with_file(const uint8_t *zid, const char *file_path);

/// Frees a ZRTP context previously created by `zrtp_context_new`.
///
/// # Safety
/// The `ctx` pointer must be a valid pointer to a `ZrtpContext` or null.
void zrtp_context_free(ZrtpContext *ctx);

/// Handles a protocol event and optional packet data.
///
/// # Safety
/// The `ctx` pointer must be valid. If `data` is not null, it must point to at
/// least `len` bytes of valid memory.
void zrtp_handle_event(ZrtpContext *ctx, int32_t event, const uint8_t *data, size_t len);

/// Retrieves the next message from the engine's output queue.
///
/// Returns the number of bytes copied into `buf`. If the buffer is too small,
/// the message is truncated. Returns 0 if no message is available.
///
/// # Safety
/// The `ctx` pointer must be valid. `buf` must point to at least `max_len` bytes
/// of valid memory.
size_t zrtp_get_message(ZrtpContext *ctx, uint8_t *buf, size_t max_len);

/// Returns the current numeric state of the protocol engine.
///
/// # Safety
/// The `ctx` pointer must be valid.
int32_t zrtp_get_state(ZrtpContext *ctx);

/// Sets a callback to be notified of protocol state changes.
///
/// # Safety
/// The `ctx` pointer must be valid.
void zrtp_set_status_callback(ZrtpContext *ctx, ZrtpStatusCallback callback, void *user_data);

/// Retrieves the SAS as a 4-character Base32 string.
///
/// Returns 4 if SAS is available, 0 otherwise.
///
/// # Safety
/// The `ctx` pointer must be valid. `buf` must point to at least 4 bytes.
size_t zrtp_get_sas_string(ZrtpContext *ctx, uint8_t *buf);

/// Retrieves the SAS hash (32 bytes).
///
/// Returns 32 if keys are available, 0 otherwise.
///
/// # Safety
/// The `ctx` pointer must be valid. `sas` must point to at least 32 bytes of
/// valid memory.
size_t zrtp_get_sas(ZrtpContext *ctx, uint8_t *sas);

/// Retrieves the SRTP master key for the given role (Initiator or Responder).
///
/// # Safety
/// The `ctx` pointer must be valid. `key` must point to at least `key_len` bytes.
size_t zrtp_get_srtp_key(ZrtpContext *ctx, bool is_initiator, uint8_t *key, size_t key_len);

/// Retrieves the SRTP master salt for the given role (Initiator or Responder).
///
/// # Safety
/// The `ctx` pointer must be valid. `salt` must point to at least 14 bytes.
size_t zrtp_get_srtp_salt(ZrtpContext *ctx, bool is_initiator, uint8_t *salt);

} // extern "C"

} // namespace zrtp

#endif // ZRTP_FFI_H
