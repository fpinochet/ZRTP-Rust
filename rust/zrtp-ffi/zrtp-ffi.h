/* Generated by cbindgen - DO NOT EDIT */

#ifndef ZRTP_FFI_H
#define ZRTP_FFI_H

#include <cstdarg>
#include <cstdint>
#include <cstdlib>
#include <ostream>
#include <new>

namespace zrtp {

/// The main ZRTP protocol engine context.
///
/// This struct manages the state machine, cryptographic providers,
/// retransmission logic, and message queuing.
struct ZrtpContext;

/// Callback for state changes.
using ZrtpStatusCallback = void(*)(ZrtpContext *ctx, int32_t state, void *user_data);

/// C-compatible options for ZRTP enhancements.
struct ZrtpOptionsFFI {
  bool enable_ratchet;
  uint32_t ratchet_interval;
  bool enable_pqc_kem;
  bool enable_pqc_sig;
  bool enable_fragmentation;
  uint16_t fragmentation_threshold;
  bool enable_adaptive_timer;
  bool enable_survival_mode;
};

extern "C" {

/// Creates a new ZRTP context for a given ZID.
///
/// This is the base function for creating a context without persistent storage.
/// In-memory caching will be used.
///
/// # Arguments
/// * `zid` - Pointer to a 12-byte array containing the own ZID.
///
/// # Returns
/// A pointer to the newly created `ZrtpContext`. Must be freed using `zrtp_context_free`.
///
/// # Safety
/// The `zid` pointer must point to at least 12 bytes of valid memory.
ZrtpContext *zrtp_context_new(const uint8_t *zid);

/// Creates a new ZRTP context with a persistent SQLite cache.
///
/// Use this if you want to store retained secrets in a modern, atomic database.
///
/// # Arguments
/// * `zid` - Pointer to a 12-byte array containing the own ZID.
/// * `db_path` - Null-terminated string containing the path to the SQLite file.
///
/// # Returns
/// A pointer to the `ZrtpContext`, or NULL if the database could not be opened.
///
/// # Safety
/// The `zid` pointer must point to at least 12 bytes. `db_path` must be a null-terminated string.
ZrtpContext *zrtp_context_new_with_db(const uint8_t *zid, const char *db_path);

/// Creates a new ZRTP context with a legacy binary file cache.
///
/// Use this for strict bit-compatible interoperability with the legacy C++ `names.zrid` format.
///
/// # Arguments
/// * `zid` - Pointer to a 12-byte array containing the own ZID.
/// * `file_path` - Null-terminated string containing the path to the binary cache file.
///
/// # Returns
/// A pointer to the `ZrtpContext`, or NULL if the file could not be opened.
///
/// # Safety
/// The `zid` pointer must point to at least 12 bytes. `file_path` must be a null-terminated string.
ZrtpContext *zrtp_context_new_with_file(const uint8_t *zid, const char *file_path);

/// Frees a ZRTP context previously created by `zrtp_context_new`.
///
/// # Safety
/// The `ctx` pointer must be a valid pointer to a `ZrtpContext` or null.
void zrtp_context_free(ZrtpContext *ctx);

/// Handles a protocol event and optional packet data.
///
/// This is the main entry point for processing incoming packets and timer events.
///
/// # Arguments
/// * `ctx` - Pointer to the `ZrtpContext`.
/// * `event` - The event ID (e.g., 0=Start, 1=HelloReceived).
/// * `data` - Pointer to the raw packet buffer (can be NULL for events without packets).
/// * `len` - Length of the data buffer.
///
/// # Safety
/// The `ctx` pointer must be valid. If `data` is not null, it must point to at
/// least `len` bytes of valid memory.
void zrtp_handle_event(ZrtpContext *ctx, int32_t event, const uint8_t *data, size_t len);

/// Retrieves the next message from the engine's output queue.
///
/// Returns the number of bytes copied into `buf`. If the buffer is too small,
/// the message is truncated. Returns 0 if no message is available.
///
/// # Safety
/// The `ctx` pointer must be valid. `buf` must point to at least `max_len` bytes
/// of valid memory.
size_t zrtp_get_message(ZrtpContext *ctx, uint8_t *buf, size_t max_len);

/// Returns the current numeric state of the protocol engine.
///
/// # Safety
/// The `ctx` pointer must be valid.
int32_t zrtp_get_state(ZrtpContext *ctx);

/// Sets a callback to be notified of protocol state changes.
///
/// # Safety
/// The `ctx` pointer must be valid.
void zrtp_set_status_callback(ZrtpContext *ctx, ZrtpStatusCallback callback, void *user_data);

/// Retrieves the SAS as a 4-character Base32 string.
///
/// Returns 4 if SAS is available, 0 otherwise.
///
/// # Safety
/// The `ctx` pointer must be valid. `buf` must point to at least 4 bytes.
size_t zrtp_get_sas_string(ZrtpContext *ctx, uint8_t *buf);

/// Retrieves the SAS hash (32 bytes).
///
/// Returns 32 if keys are available, 0 otherwise.
///
/// # Safety
/// The `ctx` pointer must be valid. `sas` must point to at least 32 bytes of
/// valid memory.
size_t zrtp_get_sas(ZrtpContext *ctx, uint8_t *sas);

/// Retrieves the SRTP master key for the given role (Initiator or Responder).
///
/// # Safety
/// The `ctx` pointer must be valid. `key` must point to at least `key_len` bytes.
size_t zrtp_get_srtp_key(ZrtpContext *ctx, bool is_initiator, uint8_t *key, size_t key_len);

/// Retrieves the SRTP master salt for the given role (Initiator or Responder).
///
/// # Safety
/// The `ctx` pointer must be valid. `salt` must point to at least 14 bytes.
size_t zrtp_get_srtp_salt(ZrtpContext *ctx, bool is_initiator, uint8_t *salt);

/// Configures the ZRTP context with modern enhancements.
///
/// # Safety
/// The `ctx` pointer must be valid. `options` must be a valid pointer.
void zrtp_context_configure(ZrtpContext *ctx, const ZrtpOptionsFFI *options);

/// Advances the symmetric ratchet and retrieves the next SRTP master key.
///
/// Use this if the ratchet is enabled to update the session key periodically.
///
/// # Safety
/// The `ctx` pointer must be valid. `key_buf` must point to at least 32 bytes.
size_t zrtp_ratchet_next_key(ZrtpContext *ctx, bool is_initiator, uint8_t *key_buf);

} // extern "C"

} // namespace zrtp

#endif // ZRTP_FFI_H
